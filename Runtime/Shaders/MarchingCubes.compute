#pragma kernel March
#include "MarchTables.compute"

static const int numThreads = 1;

struct Triangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
    //float2 uvA;
    //float2 uvB;
    //float2 uvC;
};

struct Dato {
    float3 posicion;
    float valor;
};

AppendStructuredBuffer<Triangle> triangles;
StructuredBuffer<Dato> datos;
StructuredBuffer<int> indices;
//StructuredBuffer<float2> uvs;
//StructuredBuffer<float2> uvs2;
//StructuredBuffer<float4> colores;

int cantidadPorEje;
float isoLevel;

float3 interpolateFloat4(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
}

float2 interpolateFloat3(float3 v1, float3 v2) {
    float t = (isoLevel - v1.z) / (v2.z - v1.z);
    return v1.xy + t * (v2.xy - v1.xy);
}

float4 pointAtIndex(int i) {
    Dato dato = datos[i];
    return float4(dato.posicion, dato.valor);
}

/*
float3 uvAtIndex(int i) {
    float valor = datos[i].valor;
    float2 uv = uvs[i];
    return float3(uv, valor);
}

float3 uv2AtIndex(int i) {
    float valor = datos[i].valor;
    float2 uv2 = uvs2[i];
    return float3(uv2, valor);
}

float4 colorAtIndex(int i) {
    float valor = datos[i].valor;
    float3 color = colores[i].rgb;
    return float4(color, valor);
}
*/

[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID) {

    int indice = id.x + id.y * cantidadPorEje + id.z * cantidadPorEje * cantidadPorEje;

    if (indice >= cantidadPorEje * cantidadPorEje * cantidadPorEje)
        return;

    indice *= 8;

    float4 cubeCorners[8] = {
        pointAtIndex(indices[indice]),  
        pointAtIndex(indices[indice + 1]),
        pointAtIndex(indices[indice + 2]),
        pointAtIndex(indices[indice + 3]),
        pointAtIndex(indices[indice + 4]),
        pointAtIndex(indices[indice + 5]),
        pointAtIndex(indices[indice + 6]),
        pointAtIndex(indices[indice + 7])
    };

    /*
    float3 uvCorners[8] = {
        uvAtIndex(indices[id.x]),
        uvAtIndex(indices[id.x + 1]),
        uvAtIndex(indices[id.x + 2]),
        uvAtIndex(indices[id.x + 3]),
        uvAtIndex(indices[id.x + 4]),
        uvAtIndex(indices[id.x + 5]),
        uvAtIndex(indices[id.x + 6]),
        uvAtIndex(indices[id.x + 7])
    };
    */

    int cubeIndex = 0;
    for (int j = 0, nivel = 1; j < 8; j++, nivel *= 2) {
        cubeIndex |= nivel * (cubeCorners[j].w < isoLevel);
    }

    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 2]];

        Triangle tri;

        tri.vertexA = interpolateFloat4(cubeCorners[a0], cubeCorners[b0]);
        //tri.uvA = interpolateFloat3(uvCorners[a0], uvCorners[b0]);
        tri.vertexB = interpolateFloat4(cubeCorners[a1], cubeCorners[b1]);
        //tri.uvB = interpolateFloat3(uvCorners[a1], uvCorners[b1]);
        tri.vertexC = interpolateFloat4(cubeCorners[a2], cubeCorners[b2]);
        //tri.uvC = interpolateFloat3(uvCorners[a2], uvCorners[b2]);

        triangles.Append(tri);
    }
}
