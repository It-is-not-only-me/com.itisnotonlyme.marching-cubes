#pragma kernel March
#include "MarchTables.compute"

static const int numThreads = 1;

struct Vertice {
    float3 vertex;
    float4 uvs;
};

struct Triangle {
    Vertice verticeA;
    Vertice verticeB;
    Vertice verticeC;
};

struct Dato {
    float3 posicion;
    float valor;
};

AppendStructuredBuffer<Triangle> triangles;
StructuredBuffer<Dato> datos;
StructuredBuffer<int> indices;

StructuredBuffer<float4> uvs;
bool usaUVs;

int cantidadPorEje;
int cantidadIndices;
float isoLevel;

float invLerp(float from, float to, float value) {
    return (value - from) / (to - from);
}

float3 interpolate(float3 v1, float valorInterpolacion1, float3 v2, float valorInterpolacion2) {
    float t = invLerp(valorInterpolacion1, valorInterpolacion2, isoLevel);
    return lerp(v1, v2, t);
}

float4 interpolateExtremos(float4 v1, float valorInterpolacion, float4 v2) {
    return lerp(v1, v2, valorInterpolacion > isoLevel);
}


[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID) {

    int indice = (id.x + id.y * cantidadPorEje + id.z * cantidadPorEje * cantidadPorEje) * 8;

    if (indice >= cantidadIndices) return;

    float3 cubeCorners[8];
    float4 uvCorners[8];
    float valorCorners[8];

    for (int w = 0; w < 8; w++) {
        int indiceActual = indices[indice + w];
        Dato datoActual = datos[indiceActual];

        cubeCorners[w] = datoActual.posicion;
        uvCorners[w] = uvs[indiceActual];
        valorCorners[w] = datoActual.valor;
    }

    int cubeIndex = 0;
    for (int j = 0, nivel = 1; j < 8; j++, nivel *= 2) {
        cubeIndex |= nivel * (valorCorners[j] < isoLevel);
    }

    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

        Vertice vertices[3];

        for (int z = 0; z < 3; z++) {
            int a = cornerIndexAFromEdge[triangulation[cubeIndex][i + z]];
            int b = cornerIndexBFromEdge[triangulation[cubeIndex][i + z]];

            vertices[z].vertex = interpolate(cubeCorners[a], valorCorners[a], cubeCorners[b], valorCorners[b]);
            vertices[z].uvs = float4(0, 0, 0, 0) + (usaUVs * interpolateExtremos(uvCorners[a], valorCorners[a], uvCorners[b]));
        }

        Triangle tri;
        tri.verticeA = vertices[0];
        tri.verticeB = vertices[1];
        tri.verticeC = vertices[2];
        triangles.Append(tri);
    }
}
