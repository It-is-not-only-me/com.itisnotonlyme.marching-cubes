#pragma kernel March
#include "MarchTables.compute"

static const int numThreads = 1;

struct Vertice {
    float3 vertex;
    float2 uv;
    float2 uv2;
    float3 color;
};

struct Triangle {
    float3 vertexA;
    float2 uvA;
    float2 uv2A;
    float3 colorA;
    float3 vertexB;
    float2 uvB;
    float2 uv2B;
    float3 colorB;
    float3 vertexC;
    float2 uvC;
    float2 uv2C;
    float3 colorC;
};

struct Dato {
    float3 posicion;
    float valor;
};

AppendStructuredBuffer<Triangle> triangles;
StructuredBuffer<Dato> datos;
StructuredBuffer<int> indices;
StructuredBuffer<float2> uvs;
StructuredBuffer<float2> uvs2;
StructuredBuffer<float4> colores;

int cantidadPorEje;
int cantidadIndices;
float isoLevel;

float3 interpolateFloat4(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
}

float2 interpolateFloat3(float3 v1, float3 v2) {
    float t = (isoLevel - v1.z) / (v2.z - v1.z);
    return v1.xy + t * (v2.xy - v1.xy);
}

float4 pointAtIndex(int i) {
    Dato dato = datos[i];
    return float4(dato.posicion, dato.valor);
}

float3 uvAtIndex(int i) {
    float valor = datos[i].valor;
    float2 uv = uvs[i];
    return float3(uv, valor);
}

float3 uv2AtIndex(int i) {
    float valor = datos[i].valor;
    float2 uv2 = uvs2[i];
    return float3(uv2, valor);
}

float4 colorAtIndex(int i) {
    float valor = datos[i].valor;
    float3 color = colores[i].rgb;
    return float4(color, valor);
}

Triangle crearTriangulo(Vertice verticeA, Vertice verticeB, Vertice verticeC) {

    Triangle triangulo;

    triangulo.vertexA = verticeA.vertex;
    triangulo.uvA = verticeA.uv;
    triangulo.uv2A = verticeA.uv2;
    triangulo.colorA = verticeA.color;

    triangulo.vertexB = verticeB.vertex;
    triangulo.uvB = verticeB.uv;
    triangulo.uv2B = verticeB.uv2;
    triangulo.colorB = verticeB.color;

    triangulo.vertexC = verticeC.vertex;
    triangulo.uvC = verticeC.uv;
    triangulo.uv2C = verticeC.uv2;
    triangulo.colorC = verticeC.color;

    return triangulo;
}

[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID) {

    int indice = (id.x + id.y * cantidadPorEje + id.z * cantidadPorEje * cantidadPorEje) * 8;

    if (indice >= cantidadIndices) return;

    float4 cubeCorners[8];
    float3 uvCorners[8];
    float3 uv2Corners[8];
    float4 colorCorners[8];

    for (int w = 0; w < 8; w++) {
        int indiceActual = indices[indice + w];
        cubeCorners[w] = pointAtIndex(indiceActual);
        uvCorners[w] = uvAtIndex(indiceActual);
        uv2Corners[w] = uv2AtIndex(indiceActual);
        colorCorners[w] = colorAtIndex(indiceActual);
    }

    int cubeIndex = 0;
    for (int j = 0, nivel = 1; j < 8; j++, nivel *= 2) {
        cubeIndex |= nivel * (cubeCorners[j].w < isoLevel);
    }

    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

        Vertice vertices[3];

        for (int z = 0; z < 3; z++) {
            int a = cornerIndexAFromEdge[triangulation[cubeIndex][i + z]];
            int b = cornerIndexBFromEdge[triangulation[cubeIndex][i + z]];

            vertices[z].vertex = interpolateFloat4(cubeCorners[a], cubeCorners[b]);
            vertices[z].uv = interpolateFloat3(uvCorners[a], uvCorners[b]);
            vertices[z].uv2 = interpolateFloat3(uv2Corners[a], uv2Corners[b]);
            vertices[z].color = interpolateFloat4(colorCorners[a], colorCorners[b]);
        }

        triangles.Append(crearTriangulo(vertices[0], vertices[1], vertices[2]));
    }
}
