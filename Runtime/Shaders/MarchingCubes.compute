#pragma kernel March
#include "MarchTables.compute"

static const int numThreads = 1;

struct Vertice {
    float3 vertex;
    float4 uvs;
};

struct Triangle {
    Vertice verticeA;
    Vertice verticeB;
    Vertice verticeC;
};

AppendStructuredBuffer<Triangle> triangles;

Texture2D<float4> datos;
Texture2D<float4> uvs;
uint anchoTextura;

StructuredBuffer<int> indices;

int cantidadPorEje;
int cantidadIndices;
float isoLevel;

float invLerp(float from, float to, float value) {
    return (value - from) / (to - from);
}

float3 interpolate(float3 v1, float valorInterpolacion1, float3 v2, float valorInterpolacion2) {
    float t = invLerp(valorInterpolacion1, valorInterpolacion2, isoLevel);
    return lerp(v1, v2, t);
}

float4 interpolateExtremos(float4 v1, float valorInterpolacion, float4 v2) {
    return lerp(v1, v2, valorInterpolacion > isoLevel);
}

int2 posicionEnTextura(uint indice) {
    return int2(indice / anchoTextura, indice % anchoTextura);
}

[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID) {

    int indice = (id.x + id.y * cantidadPorEje + id.z * cantidadPorEje * cantidadPorEje) * 8;

    if (indice >= cantidadIndices) return;

    float3 cubeCorners[8];
    float4 uvCorners[8];
    float valorCorners[8];

    for (int w = 0; w < 8; w++) {
        int2 posicion = posicionEnTextura((uint)indices[indice + w]);

        cubeCorners[w] = datos[posicion].xyz;
        uvCorners[w] = uvs[posicion];
        valorCorners[w] = datos[posicion].w;
    }

    int cubeIndex = 0;
    for (int j = 0, nivel = 1; j < 8; j++, nivel *= 2) {
        cubeIndex |= nivel * (valorCorners[j] < isoLevel);
    }

    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

        Vertice vertices[3];

        for (int z = 0; z < 3; z++) {
            int a = cornerIndexAFromEdge[triangulation[cubeIndex][i + z]];
            int b = cornerIndexBFromEdge[triangulation[cubeIndex][i + z]];

            vertices[z].vertex = interpolate(cubeCorners[a], valorCorners[a], cubeCorners[b], valorCorners[b]);
            vertices[z].uvs = interpolateExtremos(uvCorners[a], valorCorners[a], uvCorners[b]);
        }

        Triangle tri;
        tri.verticeA = vertices[0];
        tri.verticeB = vertices[1];
        tri.verticeC = vertices[2];
        triangles.Append(tri);
    }
}
