#pragma kernel March
#include "MarchTables.compute"

static const int numThreads = 1;

struct Triangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
    float2 uvA;
    float2 uvB;
    float2 uvC;
    /*
    float2 uv2A;
    float2 uv2B;
    float2 uv2C;
    float3 colorA;
    float3 colorB;
    float3 colorC;*/
};

struct Dato {
    float3 posicion;
    float valor;
};

AppendStructuredBuffer<Triangle> triangles;
StructuredBuffer<Dato> datos;
StructuredBuffer<int> indices;
StructuredBuffer<float2> uvs;
//StructuredBuffer<float2> uvs2;
//StructuredBuffer<float4> colores;

int cantidadPorEje;
int cantidadIndices;
float isoLevel;

float3 interpolateFloat4(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
}

float2 interpolateFloat3(float3 v1, float3 v2) {
    float t = (isoLevel - v1.z) / (v2.z - v1.z);
    return v1.xy + t * (v2.xy - v1.xy);
}

float4 pointAtIndex(int i) {
    Dato dato = datos[i];
    return float4(dato.posicion, dato.valor);
}

float3 uvAtIndex(int i) {
    float valor = datos[i].valor;
    float2 uv = uvs[i];
    return float3(uv, valor);
}

/*
float3 uv2AtIndex(int i) {
    float valor = datos[i].valor;
    float2 uv2 = uvs2[i];
    return float3(uv2, valor);
}

float4 colorAtIndex(int i) {
    float valor = datos[i].valor;
    float3 color = colores[i].rgb;
    return float4(color, valor);
}
*/

[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID) {

    int indice = (id.x + id.y * cantidadPorEje + id.z * cantidadPorEje * cantidadPorEje) * 8;

    if (indice >= cantidadIndices) return;

    float4 cubeCorners[8];
    float3 uvCorners[8];

    for (int w = 0; w < 8; w++) {
        int indiceActual = indices[indice + w];
        cubeCorners[w] = pointAtIndex(indiceActual);
        uvCorners[w] = uvAtIndex(indiceActual);
    }

    int cubeIndex = 0;
    for (int j = 0, nivel = 1; j < 8; j++, nivel *= 2) {
        cubeIndex |= nivel * (cubeCorners[j].w < isoLevel);
    }

    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 2]];

        Triangle tri;

        tri.vertexA = interpolateFloat4(cubeCorners[a0], cubeCorners[b0]);
        tri.uvA = interpolateFloat3(uvCorners[a0], uvCorners[b0]);
        tri.vertexB = interpolateFloat4(cubeCorners[a1], cubeCorners[b1]);
        tri.uvB = interpolateFloat3(uvCorners[a1], uvCorners[b1]);
        tri.vertexC = interpolateFloat4(cubeCorners[a2], cubeCorners[b2]);
        tri.uvC = interpolateFloat3(uvCorners[a2], uvCorners[b2]);

        triangles.Append(tri);
    }
}
